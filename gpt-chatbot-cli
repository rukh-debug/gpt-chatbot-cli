#!/usr/bin/env python3
import openai
import os
import termcolor
from prompt_toolkit import prompt
from prompt_toolkit.validation import Validator, ValidationError
from prompt_toolkit.styles import Style
import click
import time

from tinydb import TinyDB, Query

db = TinyDB('db/gpt_chatbot_chat_history.json')

from src.payloads import presets, chat_complitions_models

def print_char_by_char(start_string, text):
    print(start_string, end=" ")
    for char in text:
        print(termcolor.colored(char, 'light_yellow'), end='', flush=True)
        time.sleep(0.01)
    print()

@click.command()
@click.option('--api_key', '-k', help='Openai API key. If not provided, will prompt for it or use the environment variable OPENAI_API_KEY.')
@click.option('--model', '-m', default='gpt-3.5-turbo', help='Model to use for text generation | (default: gpt-3.5-turbo)')
@click.option('--temperature', '-t', default=0.9, type=click.FLOAT, help='Temperature for text generation | (default: 0.9)')
@click.option('--preset', '-p', default='chat', help='Preset mode to use for text generation | (default: Chat) \nAvailable presets: Chat, Q&A, Grammar Correction, Eli5, Custom')
@click.help_option('--help', '-h')
def generate_text(api_key, model, temperature, preset):
    """
    A CLI for OpenAI's GPT-3 API.
    Chat with a bot, ask questions, correct grammar, summarize text, and more.

    \b
    Examples:
        gpt-chatbot-cli
        gpt-chatbot-cli --api_key=YOUR_API_KEY
        gpt-chatbot-cli --api_key=YOUR_API_KEY --model=text-davinci-003 --temperature=0.7
    """

    def api_key_helper():
        return [('class:api-key-helper', 'Set the environment variable OPENAI_API_KEY to avoid further prompts. ')]


    def chat_prompt_helper(on, message):
            return [('class:chat-prompt-helper', "Mode: "+on+"\n"+message)]

    style = Style.from_dict({
        # make a gruvbox theme for this
        'api-key-helper': '#fc802d bg:#282828 bold',
        # a compatable color for the prompt
        'chat-prompt-helper': 'bg:#000000 #ffffff',
    })

    def check_api_key_validity(api_key, where):
        if(where == "prompt"):
            print("Found env variable OPENAI_API_KEY")
        print("Checking for validity")
        try:
            openai.api_key = api_key
            openai.Model.list()
            print(termcolor.colored(f"API key is valid", 'light_green', attrs=["bold"]))
        except openai.OpenAIError as e:
            print(termcolor.colored(f"Invalid API key", 'light_red', attrs=["bold"]) + "\nGrab your API key from: "+termcolor.colored(f"https://platform.openai.com/account/api-keys", 'light_blue', attrs=["underline"]))
            exit()
    # import api key
    openai_api_key = os.environ.get("OPENAI_API_KEY") or api_key

    if not openai_api_key:
        try:
            openai_api_key = prompt("Please enter your OpenAI API key: ", bottom_toolbar=api_key_helper, style=style)
            check_api_key_validity(openai_api_key, "not-prompt")
        except KeyboardInterrupt:
            print("Exiting...")
            exit(0)
    else:
        check_api_key_validity(openai_api_key, "prompt")

    # set model and temperature
    lang_model = model
    config_temperature = temperature

    # Initialize conversation_history
    conversation_history = ''
    messages = []

    try:
        chosen_preset = preset
        # replace chosen_preset with preset's actual name keeping the case
        
        # create a list of lowercase keys from presets dictionary
        preset_keys = [key.lower() for key in presets.keys()]
        
        # find the index of the lowercase version of chosen_preset
        index = preset_keys.index(chosen_preset.lower())
        
        # get the actual key name from presets dictionary using the index
        chosen_preset = list(presets.keys())[index]

        if chosen_preset in presets:
            conversation_history += presets[chosen_preset]["message"]
            messages.append({
                "role": "system", "content": presets[chosen_preset]["message"]
            })
        else:
            print("Invalid preset chosen, please try again.")
            exit()
            
        # Replace #END# and #START# with preset's end and start's string if available
        if "inject" in presets[chosen_preset] and presets[chosen_preset]["inject"]["state"]:
            state = True
            end_string = presets[chosen_preset]["inject"]["end"]
            start_string = presets[chosen_preset]["inject"]["start"]
        else:
            state = False
            end_string = ">"
            start_string = ">"
            
        # start chat loop
        while True:
            # get user input
            user_input = prompt(end_string, bottom_toolbar=chat_prompt_helper(chosen_preset, presets[chosen_preset]["message"]), style=style)

            if user_input.lower() in ["exitgpt","exit"]:
                break


            if lang_model in chat_complitions_models:
                messages.append({
                    "role": "user", "content": user_input
                })
                
                response = openai.ChatCompletion.create(
                    model=lang_model,
                    messages=messages,
                )
                # print(response)
                print_char_by_char(start_string, response.choices[0].message.content)
                messages.append({
                    "role": response.choices[0].message.role, "content": response.choices[0].message.content
                })
                # print(messages)
            else: 
                response = openai.Completion.create(
                    engine=lang_model,
                    prompt=conversation_history + end_string + user_input + "\n" + start_string,
                    temperature=config_temperature,
                    max_tokens=1024,
                )
                # print(response)
                if (state):
                    conversation_history += end_string + user_input + "\n" + response.choices[0].text + "\n"
                else:
                    conversation_history = presets[chosen_preset]["message"]
                print_char_by_char(start_string, response.choices[0].text)


    except Exception as e:
        print(termcolor.colored(f"Error: {e}", 'light_red'))
        exit(1)
    except KeyboardInterrupt:
        print(termcolor.colored(f"Keyboard Interrupt, Exiting...", 'light_red'))
        exit(0)


if __name__ == '__main__':
    generate_text()
